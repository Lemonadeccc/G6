(("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@antv/g6-site"]=("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@antv/g6-site"]||[]).push([["7a246ae5"],{"7a246ae5":function(e,a,d){"use strict";d.d(a,"__esModule",{value:!0}),d.d(a,"texts",{enumerable:!0,get:function(){return t;}}),d("b6403f8d");let t=[{value:" Edge bundling is a graph visualization technique used to reduce visual clutter in complex network graphs and reveal high-level patterns and structures in the graph. The idea is to bundle adjacent edges together.",paraId:0},{value:" The edge bundling plugin provided in G6 is based on the implementation of the paper FEDB (Force-Directed Edge Bundling for Graph Visualization): modeling edges as flexible springs that can attract each other and bundling them in a self-organizing way.",paraId:1},{value:"string",paraId:2,tocIndex:1},{value:"Plugin key, that is, the unique identifier",paraId:3,tocIndex:1},{value:" Used to identify the plugin for further operations",paraId:4,tocIndex:1},{value:"// Get plugin instance\r\nconst plugin = graph.getPluginInstance('key');\r\n// Update plugin options\r\ngraph.updatePlugin({key: 'key', ...});\n",paraId:5,tocIndex:1},{value:"Required",paraId:6,tocIndex:1},{value:"string",paraId:7,tocIndex:2},{value:"Plugin type",paraId:8,tocIndex:2},{value:"number",paraId:9,tocIndex:3},{value:" ",paraId:9,tocIndex:3},{value:"Default:",paraId:9,tocIndex:3},{value:" ",paraId:9,tocIndex:3},{value:"0.6",paraId:9,tocIndex:3},{value:"Edge compatibility threshold, which determines which edges should be bundled together",paraId:10,tocIndex:3},{value:"number",paraId:11,tocIndex:4},{value:" ",paraId:11,tocIndex:4},{value:"Default:",paraId:11,tocIndex:4},{value:" ",paraId:11,tocIndex:4},{value:"6",paraId:11,tocIndex:4},{value:"The number of simulation cycles",paraId:12,tocIndex:4},{value:"number",paraId:13,tocIndex:5},{value:" ",paraId:13,tocIndex:5},{value:"Default:",paraId:13,tocIndex:5},{value:" ",paraId:13,tocIndex:5},{value:"1",paraId:13,tocIndex:5},{value:"An initial number of subdivision points for each edge. In subsequent cycles, the number of subdivision points will increase gradually according to ",paraId:14,tocIndex:5},{value:"divRate",paraId:14,tocIndex:5},{value:"number",paraId:15,tocIndex:6},{value:" ",paraId:15,tocIndex:6},{value:"Default:",paraId:15,tocIndex:6},{value:" ",paraId:15,tocIndex:6},{value:"2",paraId:15,tocIndex:6},{value:"The rate at which the number of subdivision points increases",paraId:16,tocIndex:6},{value:"number",paraId:17,tocIndex:7},{value:" ",paraId:17,tocIndex:7},{value:"Default:",paraId:17,tocIndex:7},{value:" ",paraId:17,tocIndex:7},{value:"90",paraId:17,tocIndex:7},{value:"The number of iteration steps during the first cycle. In subsequent cycles, the number of iterations will decrease gradually according to ",paraId:18,tocIndex:7},{value:"iterRate",paraId:18,tocIndex:7},{value:"number",paraId:19,tocIndex:8},{value:" ",paraId:19,tocIndex:8},{value:"Default:",paraId:19,tocIndex:8},{value:" ",paraId:19,tocIndex:8},{value:"2 / 3",paraId:19,tocIndex:8},{value:"The rate at which the number of iterations decreases",paraId:20,tocIndex:8},{value:"number",paraId:21,tocIndex:9},{value:" ",paraId:21,tocIndex:9},{value:"Default:",paraId:21,tocIndex:9},{value:" ",paraId:21,tocIndex:9},{value:"0.1",paraId:21,tocIndex:9},{value:"The strength of the edge",paraId:22,tocIndex:9},{value:"number",paraId:23,tocIndex:10},{value:" ",paraId:23,tocIndex:10},{value:"Default:",paraId:23,tocIndex:10},{value:" ",paraId:23,tocIndex:10},{value:"0.1",paraId:23,tocIndex:10},{value:"An initial step size. In subsequent cycles, the step size will double incrementally",paraId:24,tocIndex:10},{value:"destroy(): void;\n",paraId:25,tocIndex:12}];}}]);
//# sourceMappingURL=7a246ae5-async.3a40f661.js.map